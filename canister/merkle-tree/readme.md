# Secure Merkle Tree with SHA256 for ICP

A Motoko smart contract for the Internet Computer Protocol (ICP) that implements a secure Merkle Tree using SHA256 for hash generation. This contract is designed for verifying and managing sensor readings with cryptographic proofs.

## Features

- SHA256-based hash generation
- Merkle tree implementation with secure proofs
- Support for multiple sensor readings
- Efficient data verification system
- Comprehensive test functionality
- Tree statistics and monitoring

## Data Structures

### Types
```motoko
private type HashType = Text;
private type Timestamp = Int;

private type SensorReading = {
    sensorHash: HashType;
    timestamp: Timestamp;
};

private type MerkleTreeRecord = {
    rootHash: HashType;
    readings: [SensorReading];
    timestamp: Timestamp;
    totalReadings: Nat;
};
```

## Core Functions

### Creating Merkle Trees
```motoko
public shared func createSensorMerkleTree(readings: [Text]) : async Result.Result<MerkleTreeRecord, Text>
```
Creates a new Merkle tree from an array of sensor readings. Each reading is hashed using SHA256.

### Data Verification
```motoko
public query func verifySensorReading(rootHash: HashType, sensorHash: Text) : async Bool
```
Verifies if a specific sensor reading exists in a given Merkle tree.

### Getting Merkle Proofs
```motoko
public query func getMerkleProof(rootHash: HashType, dataHash: Text) : async ?{
    proof: [HashType];
    index: Nat;
}
```
Generates a Merkle proof for a specific data hash.

### Verifying Proofs
```motoko
public query func verifyMerkleProof(
    rootHash: HashType,
    dataHash: Text,
    proof: [HashType],
    index: Nat
) : async Bool
```
Verifies a Merkle proof for a given data hash.

## Usage Examples

### Creating a New Merkle Tree
```motoko
// Create sensor readings
let readings = [
    "sensor1_reading_123",
    "sensor2_reading_456",
    "sensor3_reading_789"
];

// Create Merkle tree
let result = await contract.createSensorMerkleTree(readings);
switch(result) {
    case (#ok(tree)) {
        // Tree created successfully
        let rootHash = tree.rootHash;
    };
    case (#err(error)) {
        // Handle error
    };
};
```

### Verifying Data
```motoko
// Verify a reading exists
let exists = await contract.verifySensorReading(rootHash, "sensor1_reading_123");

// Get and verify proof
let proofResult = await contract.getMerkleProof(rootHash, "sensor1_reading_123");
switch(proofResult) {
    case (?merkleProof) {
        let isValid = await contract.verifyMerkleProof(
            rootHash,
            "sensor1_reading_123",
            merkleProof.proof,
            merkleProof.index
        );
    };
    case (null) {
        // Handle not found case
    };
};
```

## Querying Tree Information

### Get Latest Tree
```motoko
public query func getLatestTree() : async ?MerkleTreeRecord
```
Returns the most recently created Merkle tree.

### Get Tree Statistics
```motoko
public query func getTreeStats() : async Text
```
Returns comprehensive statistics about all stored trees including:
- Total number of trees
- Total number of readings
- Average readings per tree
- Maximum/minimum readings
- Last update timestamp

## Security Features

1. **SHA256 Hashing**
   - Cryptographically secure hash generation
   - Built-in SHA256 implementation
   - No external dependencies

2. **Safe Memory Management**
   - Efficient buffer usage
   - Stable variable handling for upgrades
   - Safe type operations

3. **Data Integrity**
   - Merkle proof verification
   - Timestamp tracking
   - Unique hash generation

## Testing

The contract includes a built-in testing function:
```motoko
public func testMerkleVerification() : async Text
```
This function runs a comprehensive test suite that:
- Creates a test Merkle tree
- Verifies multiple readings
- Tests proof generation and verification
- Tests invalid data handling

## Installation

1. Make sure you have the [DFINITY SDK](https://sdk.dfinity.org) installed
2. Clone this repository
3. Deploy using:
```bash
dfx deploy
```

## Technical Implementation

### SHA256
The contract includes a full implementation of SHA256, featuring:
- Standard SHA256 constants and operations
- Efficient byte manipulation
- Hexadecimal output formatting

### Merkle Tree Construction
The Merkle tree is built using:
- Paired hashing of leaves
- Bottom-up tree construction
- Efficient proof generation

### Proof Generation
Merkle proofs are generated by:
- Tracking sibling nodes
- Safe index manipulation
- Buffer-based storage

## Performance Considerations

- Efficient storage using HashMaps
- Optimized proof generation
- Minimal memory footprint
- Safe numeric operations

## Contributing

Feel free to open issues and submit pull requests to help improve this contract.

## License

[MIT License](LICENSE)

---

For more information about the Internet Computer Protocol and Motoko, visit [DFINITY Documentation](https://sdk.dfinity.org/docs/).
